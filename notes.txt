
	Notes/Insights:
		- with 64B blocks, DRAM bandwidth on FPGA [ ~ 1KB / FPGA cycle ] makes stash design complicated; this isn't a problem with 4KB blocks.
		- What matters here is bits / cycle, or blocks / cycle. <=(1 block / cycle) is usually fine, but  >(1 blocks / cycle) makes the design complicated.

		- BUT, with small block sizes (small path lengths), we can easily buffer the entire path from DRAM without having to worry about area consumption.
		
		- The stash cannot assert/deassert a ready signal in data-dependent way. In our design (hopefully), the stash never deasserts the ready signal once asserting it.  NOTE: add assertion to check for this.

		- We will count the chunks getting into/out of the stash, to decide whether a new block starts. For addrGen control, count the chunks coming out of AES units (AES should be in-order).

		- Reserved address vs. dummy bit. There will be other status bits, like child flag bits. 

		- By buffering the entire path (only possible for small block sizes), we can make the stash logic simpler bc it doesn't need scan pre-emption.
		
	Known performance bugs:
		- MIG is introducing 14 cycles of latency between CommandValid -> RAS and 5 cycles between DQ valid and ReadOutValid
		
		
		
		
		
		
	Questions to ask:
		- 	Does MIT have Synopsis Synplify?  
			No.  Arvind's group never bothered with it b/c Bluespec's backend is in terms of raw BRAM blocks
			
		-	Ease to get ASIC SRAMs
		
		-	